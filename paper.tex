%% LyX 1.6.8 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english,amsthm,seceqn,secthm]{elsart}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{verbatim}
\usepackage{prettyref}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[authoryear]{natbib}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\floatstyle{ruled}
\newfloat{algorithm}{tbp}{loa}
\floatname{algorithm}{Algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
 \let\AND\relax 
 \usepackage{algorithmic}
 \usepackage{algolyx}
 \usepackage{algolyx}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{yjsco}\journal{Journal of Symbolic Computation}

\renewcommand{\algorithmicrequire}{\textbf{Input:}}\renewcommand{\algorithmicensure}{\textbf{Output:}}\renewcommand{\algorithmicensure}{\textbf{if}}\renewcommand{\algorithmicensure}{\textbf{Uses:}}

\def\diag{\mbox{diag}}\def\cdeg{\qopname\relax n{cdeg}}\keycomment{\{\{}{\}\}}\def\MM{\qopname\relax n{MM}}\def\M{\qopname\relax n{M}}\def\ord{\qopname\relax n{ord}}

\def\StorjohannTransform{\qopname\relax n{StorjohannTransform}}\def\TransformUnbalanced{\qopname\relax n{TransformUnbalanced}}\def\rowDimension{\qopname\relax n{rowDimension}}\def\columnDimension{\qopname\relax n{columnDimension}}\DeclareMathOperator{\re}{rem}\DeclareMathOperator{\coeff}{coeff}\DeclareMathOperator{\lcoeff}{lcoeff}\def\mab{\qopname\relax n{OrderBasis}}\def\mmab{\qopname\relax n{FastBasis}}\def\umab{\qopname\relax n{UnbalancedFastBasis}}\newcommand{\bb}{\\}

\makeatother

\makeatother

\usepackage{babel}

\begin{document}
\begin{frontmatter}

\title{Efficient Algorithms for Order Bases Computation}


\author{Wei Zhou and George Labahn}


\address{{Cheriton School of Computer Science}\\
 {University of Waterloo},\\
 {Waterloo, Ontario, Canada}}


\ead{\{w2zhou,glabahn\}@uwaterloo.ca }
\begin{abstract}
In this paper we present two algorithms for the computation of a shifted
order basis of an $m\times n$ matrix of power series over a field
$\mathbb{K}$ with $m\le n$. For a given order $\sigma$ and balanced
shift $\vec{s}$ the first algorithm determines an order basis with
a cost of $O^{\sim}(n^{\omega}\lceil m\sigma/n\rceil)$ field operations
in $\mathbb{K}$, where $\omega$ is the exponent of matrix multiplication.
Here an input shift is balanced when $\max(\vec{s})-\min(\vec{s})\in O(m\sigma/n)$.
%Here $O^{\sim}$
%is just $O$ with log factors omitted and 
%$\MM\left(n,d\right)$ denotes
%the cost of multiplying two polynomial matrices with dimension $n$
%and degree $d$. 
This extends earlier work of Storjohann which only determines a subset
of an order basis that is within a specified degree bound $\delta$
using $O^{\sim}(n^{\omega}\delta)$ field operations for $\delta\ge\lceil m\sigma/n\rceil$.

While the first algorithm addresses the case when the column degrees
of a complete order basis are unbalanced given a balanced input shift,
it is not efficient in the case when an unbalanced shift results in
the row degrees also becoming unbalanced. %The column degrees of a complete basis may be unbalanced, which is
%a major issue we address in the first algorithm. When the input shift
%is unbalanced, the row degrees of the basis can also be unbalanced
%in addition to the unbalanced column degrees. For this, we present
We present a second algorithm which balances the high degree rows
and computes an order basis also using $O^{\sim}(n^{\omega}\lceil m\sigma/n\rceil)$
field operations in the case that the shift is unbalanced but satisfies
the condition $\sum_{i=1}^{n}(\max(\vec{s})-\vec{s}_{i})\le m\sigma$.%
\begin{comment}
Every problem with any unbalanced shift can be in fact reduced to
a problem with a shift that satisfying this condition if the degrees
of a resulting order basis is known. 
\end{comment}
{} %
\begin{comment}
Many unbalanced shift problems can be in fact converted to problems
satisfying this condition. 
\end{comment}
{} This condition essentially allows us to locate those high degree
rows that need to be balanced. %
\begin{comment}
In more general unbalanced shift cases, this algorithm may not work
well directly since we do not know in advance which are the high degree
rows need to be balanced. But it may work efficiently if we have an
effective way of estimating the resulting row degrees. 
\end{comment}
{} This extends the earlier work by the authors from ISSAC'09.
\end{abstract}
\end{frontmatter}
\input{introduction.tex}

\input{preliminaries.tex}

\input{transform.tex}

\input{computing.tex}

\input{complexity.tex}

\input{unbalanced.tex}

\input{conclusion.tex} 

\bibliographystyle{elsart-harv}
\bibliography{paper}

\end{document}
